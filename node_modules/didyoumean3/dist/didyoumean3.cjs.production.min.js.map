{"version":3,"file":"didyoumean3.cjs.production.min.js","sources":["../src/util.ts","../src/leven.ts","../src/index.ts"],"sourcesContent":["export interface Return {\n  (x: any): any;\n}\n\nexport interface Normalize {\n  (x: string): string;\n}\n\nexport interface Filter {\n  (score: number, target: string | object): boolean;\n}\n\n/**\n * @type {boolean} ignore: ignore case 'A' -> 'a'\n * @type {boolean} trim: ' a bcs ' -> 'a bcs'\n * @type {boolean} trimAll: ' a bcs' -> 'abcs'\n * @type {boolean} diacritics: 'café' -> 'café'.normalize()\n * @type {Function} normalize: you can formatter the string yourself\n * @type {Function} result: you can custom your return result\n * @type {Function} filter: you can filter the data into the returned results\n */\nexport type Options = {\n  ignore?: boolean;\n  trim?: boolean;\n  trimAll?: boolean;\n  diacritics?: boolean;\n  normalize?: Normalize;\n  result?: Return;\n  filter?: Filter;\n};\n\nexport const isFunction = (f: any) =>\n  !!(f && f.constructor && f.call && f.apply);\n\nexport const normalize = (\n  s: string = '',\n  { normalize, trim, ignore, trimAll, diacritics }: Partial<Options>\n): string => {\n  if (isFunction(normalize)) return normalize!(s);\n\n  trim && (s = s.trim());\n  trimAll && (s = s.replace(/\\s+/g, ''));\n  diacritics && (s = s.normalize());\n  ignore && (s = s.toLowerCase());\n\n  return s;\n};\n\nexport const resultFactory = (res?: Return) => (r: any) =>\n  isFunction(res) ? res!(r) : r;\n","const V: number[] = [];\nconst C: number[] = [];\n\n// talisman\nexport const leven = (a: string, b: string): number => {\n  if (a === b) return 0;\n\n  // switch\n  const temp = a;\n  if (a.length > b.length) {\n    a = b;\n    b = temp;\n  }\n\n  let la = a.length;\n  let lb = b.length;\n\n  if (!la) return lb;\n\n  // trim common suffix, that's the reson why we need swith the params according to it's length\n  while (la > 0 && a.charCodeAt(~-la) === b.charCodeAt(~-lb)) {\n    la--;\n    lb--;\n  }\n\n  if (!la) return lb;\n\n  let start = 0;\n  while (start < la && a.charCodeAt(start) === b.charCodeAt(start)) start++;\n\n  la -= start;\n  lb -= start;\n\n  if (!la) return lb;\n\n  let i = 0;\n\n  // metrics\n  // left, right, diagonally left, dl = if char equal, diagonally left + 0 else + 1\n  // Math.min(left + 1, right + 1, dl)\n  /**\n   *   *   *   a   b   c\n   *   |   |   |   |   |\n   *   * - 0 - 1 - 2 - 3\n   *   |   |   |   |   |\n   *   a - 1 - 0 - 1 - 2\n   *   |   |   |   |   |\n   *   b - 2 - 1 - 0 - 1\n   *   |   |   |   |   |\n   *   d - 3 - 2 - 1 - 1 <- result\n   */\n  while (i < lb) {\n    C[i] = b.charCodeAt(start + i);\n    V[i] = ++i;\n  }\n\n  let curr = 0,\n    above,\n    left,\n    charA,\n    j;\n\n  for (i = 0; i < la; i++) {\n    left = i;\n    curr = i + 1;\n    charA = a.charCodeAt(start + i);\n\n    for (j = 0; j < lb; j++) {\n      above = curr;\n\n      curr = left;\n      left = V[j];\n\n      if (charA !== C[j]) {\n        if (left < curr) curr = left;\n        if (above < curr) curr = above;\n        curr++;\n      }\n\n      V[j] = curr;\n    }\n  }\n\n  return curr;\n};\n","import { normalize, resultFactory, Options } from './util';\n\nimport { leven } from './leven';\n\nconst defaultOpts: Partial<Options> = {\n  ignore: false,\n  trim: true,\n  trimAll: false,\n  diacritics: false,\n  filter: () => true,\n};\n\nconst didyoumean3 = <T extends string>(\n  s: string,\n  t: ReadonlyArray<T>,\n  opts?: Options\n): any => {\n  const { result, filter, ...cfg } = {\n    ...defaultOpts,\n    ...opts,\n  };\n  s = normalize(s, cfg);\n  const res = resultFactory(result);\n\n  if (!s || !t || !t.length) return res(null);\n\n  const matched = [];\n  let winner: T | null = null;\n  let temp: number | null = null;\n\n  for (let i = 0, len = t.length; i < len; i++) {\n    const target = t[i];\n    const score = leven(s, normalize(target, cfg));\n\n    filter!(score, target) && matched.push({ score, target });\n\n    // May be the highest score or the lowest score\n    if (temp === null || score < temp) {\n      temp = score;\n      winner = target;\n    }\n  }\n\n  return res({ matched, winner });\n};\n\ndidyoumean3.leven = leven;\n\nexport { didyoumean3 };\n\nexport default didyoumean3;\n"],"names":["isFunction","f","constructor","call","apply","normalize","s","trim","ignore","trimAll","diacritics","replace","toLowerCase","V","C","leven","a","b","temp","length","la","lb","charCodeAt","start","i","above","left","charA","j","curr","defaultOpts","filter","didyoumean3","t","opts","result","cfg","res","r","resultFactory","matched","winner","len","target","score","push"],"mappings":"oEA+BO,MAAMA,EAAcC,MACtBA,GAAKA,EAAEC,aAAeD,EAAEE,MAAQF,EAAEG,OAE1BC,EAAY,CACvBC,EAAY,IACVD,UAAAA,EAAWE,KAAAA,EAAMC,OAAAA,EAAQC,QAAAA,EAASC,WAAAA,KAEhCV,EAAWK,GAAmBA,EAAWC,IAE7CC,IAASD,EAAIA,EAAEC,QACfE,IAAYH,EAAIA,EAAEK,QAAQ,OAAQ,KAClCD,IAAeJ,EAAIA,EAAED,aACrBG,IAAWF,EAAIA,EAAEM,eAEVN,GC7CHO,EAAc,GACdC,EAAc,GAGPC,EAAQ,CAACC,EAAWC,QAC3BD,IAAMC,EAAG,OAAO,QAGdC,EAAOF,EACTA,EAAEG,OAASF,EAAEE,SACfH,EAAIC,EACJA,EAAIC,OAGFE,EAAKJ,EAAEG,OACPE,EAAKJ,EAAEE,WAENC,EAAI,OAAOC,OAGTD,EAAK,GAAKJ,EAAEM,aAAaF,KAAQH,EAAEK,aAAaD,IACrDD,IACAC,QAGGD,EAAI,OAAOC,MAEZE,EAAQ,OACLA,EAAQH,GAAMJ,EAAEM,WAAWC,KAAWN,EAAEK,WAAWC,IAAQA,OAElEH,GAAMG,EACNF,GAAME,GAEDH,EAAI,OAAOC,MAEZG,EAAI,OAgBDA,EAAIH,GACTP,EAAEU,GAAKP,EAAEK,WAAWC,EAAQC,GAC5BX,EAAEW,KAAOA,MAITC,EACAC,EACAC,EACAC,EAJEC,EAAO,MAMNL,EAAI,EAAGA,EAAIJ,EAAII,QAClBE,EAAOF,EACPK,EAAOL,EAAI,EACXG,EAAQX,EAAEM,WAAWC,EAAQC,GAExBI,EAAI,EAAGA,EAAIP,EAAIO,IAClBH,EAAQI,EAERA,EAAOH,EACPA,EAAOb,EAAEe,GAELD,IAAUb,EAAEc,KACVF,EAAOG,IAAMA,EAAOH,GACpBD,EAAQI,IAAMA,EAAOJ,GACzBI,KAGFhB,EAAEe,GAAKC,SAIJA,GC/EHC,EAAgC,CACpCtB,QAAQ,EACRD,MAAM,EACNE,SAAS,EACTC,YAAY,EACZqB,OAAQ,KAAM,GAGVC,EAAc,CAClB1B,EACA2B,EACAC,WAEMC,OAAEA,EAAFJ,OAAUA,KAAWK,GAAQ,IAC9BN,KACAI,GAEL5B,EAAID,EAAUC,EAAG8B,SACXC,EF0BsBA,CAAAA,GAAkBC,GAC9CtC,EAAWqC,GAAOA,EAAKC,GAAKA,EE3BhBC,CAAcJ,OAErB7B,IAAM2B,IAAMA,EAAEd,OAAQ,OAAOkB,EAAI,YAEhCG,EAAU,OACZC,EAAmB,KACnBvB,EAAsB,SAErB,IAAIM,EAAI,EAAGkB,EAAMT,EAAEd,OAAQK,EAAIkB,EAAKlB,IAAK,OACtCmB,EAASV,EAAET,GACXoB,EAAQ7B,EAAMT,EAAGD,EAAUsC,EAAQP,IAEzCL,EAAQa,EAAOD,IAAWH,EAAQK,KAAK,CAAED,MAAAA,EAAOD,OAAAA,KAGnC,OAATzB,GAAiB0B,EAAQ1B,KAC3BA,EAAO0B,EACPH,EAASE,UAINN,EAAI,CAAEG,QAAAA,EAASC,OAAAA,KAGxBT,EAAYjB,MAAQA"}