'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const isFunction = f => !!(f && f.constructor && f.call && f.apply);
const normalize = (s = '', {
  normalize,
  trim,
  ignore,
  trimAll,
  diacritics
}) => {
  if (isFunction(normalize)) return normalize(s);
  trim && (s = s.trim());
  trimAll && (s = s.replace(/\s+/g, ''));
  diacritics && (s = s.normalize());
  ignore && (s = s.toLowerCase());
  return s;
};
const resultFactory = res => r => isFunction(res) ? res(r) : r;

const V = [];
const C = []; // talisman

const leven = (a, b) => {
  if (a === b) return 0; // switch

  const temp = a;

  if (a.length > b.length) {
    a = b;
    b = temp;
  }

  let la = a.length;
  let lb = b.length;
  if (!la) return lb; // trim common suffix, that's the reson why we need swith the params according to it's length

  while (la > 0 && a.charCodeAt(~-la) === b.charCodeAt(~-lb)) {
    la--;
    lb--;
  }

  if (!la) return lb;
  let start = 0;

  while (start < la && a.charCodeAt(start) === b.charCodeAt(start)) start++;

  la -= start;
  lb -= start;
  if (!la) return lb;
  let i = 0; // metrics
  // left, right, diagonally left, dl = if char equal, diagonally left + 0 else + 1
  // Math.min(left + 1, right + 1, dl)

  /**
   *   *   *   a   b   c
   *   |   |   |   |   |
   *   * - 0 - 1 - 2 - 3
   *   |   |   |   |   |
   *   a - 1 - 0 - 1 - 2
   *   |   |   |   |   |
   *   b - 2 - 1 - 0 - 1
   *   |   |   |   |   |
   *   d - 3 - 2 - 1 - 1 <- result
   */

  while (i < lb) {
    C[i] = b.charCodeAt(start + i);
    V[i] = ++i;
  }

  let curr = 0,
      above,
      left,
      charA,
      j;

  for (i = 0; i < la; i++) {
    left = i;
    curr = i + 1;
    charA = a.charCodeAt(start + i);

    for (j = 0; j < lb; j++) {
      above = curr;
      curr = left;
      left = V[j];

      if (charA !== C[j]) {
        if (left < curr) curr = left;
        if (above < curr) curr = above;
        curr++;
      }

      V[j] = curr;
    }
  }

  return curr;
};

const defaultOpts = {
  ignore: false,
  trim: true,
  trimAll: false,
  diacritics: false,
  filter: () => true
};

const didyoumean3 = (s, t, opts) => {
  const {
    result,
    filter,
    ...cfg
  } = { ...defaultOpts,
    ...opts
  };
  s = normalize(s, cfg);
  const res = resultFactory(result);
  if (!s || !t || !t.length) return res(null);
  const matched = [];
  let winner = null;
  let temp = null;

  for (let i = 0, len = t.length; i < len; i++) {
    const target = t[i];
    const score = leven(s, normalize(target, cfg));
    filter(score, target) && matched.push({
      score,
      target
    }); // May be the highest score or the lowest score

    if (temp === null || score < temp) {
      temp = score;
      winner = target;
    }
  }

  return res({
    matched,
    winner
  });
};

didyoumean3.leven = leven;

exports.default = didyoumean3;
exports.didyoumean3 = didyoumean3;
//# sourceMappingURL=didyoumean3.cjs.development.js.map
